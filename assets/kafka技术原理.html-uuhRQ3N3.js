import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as t,i as n,o as r}from"./app-47u45kmc.js";const s="/veins/assets/img-DWaM6ksP.png",o={};function i(c,a){return r(),t("div",null,a[0]||(a[0]=[n('<h1 id="kafka架构设计" tabindex="-1"><a class="header-anchor" href="#kafka架构设计"><span>kafka架构设计</span></a></h1><h2 id="持久化设计" tabindex="-1"><a class="header-anchor" href="#持久化设计"><span>持久化设计</span></a></h2><p>kafka深度依赖文件系统来存储或者缓存message。磁盘的快慢取决于使用的方式，<br> 在某些情况下，顺序磁盘访问可能比随机内存访问更快。<br> 现代操作系统会尽可能地将所有空闲内存用于磁盘缓存，当内存需要被回收时，性能损耗也非常小。<br> 所有的磁盘读写操作都会用到这个缓存，因此，对于用户进程中的内存数据，如果涉及到写磁盘，<br> 那么该数据可能会同时存放了两份。<br> 对于内存中的数据，相当于缓存可以扩大一倍，在JVM环境下甚至扩大更多。<br><img src="'+s+'" alt="img.png" loading="lazy"></p><h3 id="读写常数时间复杂度" tabindex="-1"><a class="header-anchor" href="#读写常数时间复杂度"><span>读写常数时间复杂度</span></a></h3><p>持久化队列，读写互相不阻塞</p><h2 id="kafka如何保证高性能" tabindex="-1"><a class="header-anchor" href="#kafka如何保证高性能"><span>kafka如何保证高性能</span></a></h2><h3 id="零拷贝技术" tabindex="-1"><a class="header-anchor" href="#零拷贝技术"><span>零拷贝技术</span></a></h3><p>一般情况下，读写服务端应用程序请求磁盘数据并发送给客户端需要经历一下步骤：</p><ol><li>DMA（直接内存访问）将数据从磁盘中复制到内核缓冲区（PageCache）</li><li>用户程序将数据从内核缓冲区读到用户缓冲区（发生一次上下文切换）</li><li>用户程序将数据从用户缓冲区写入到内核的socket缓冲区（发生第二次上下文切换）</li><li>DMA将数据从socket缓冲区复制到网卡<br> 一共发生<strong>四次</strong>数据复制，<strong>两次</strong>上下文切换</li></ol><p>可以看到数据最终是从磁盘复制到了网卡，中间的两次数据复制完全没有必要，<br> 而基于零拷贝技术，可以将中间两层的复制操作移除，直接从PageCache复制到网络。<br> 所谓零拷贝，不是说不存在数据拷贝了，而是说不存在CPU的数据拷贝了，所有拷贝动作都由DMA完成。</p><h3 id="端到端压缩" tabindex="-1"><a class="header-anchor" href="#端到端压缩"><span>端到端压缩</span></a></h3>',11)]))}const m=e(o,[["render",i],["__file","kafka技术原理.html.vue"]]),l=JSON.parse('{"path":"/backend/message/kafka%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86.html","title":"kafka架构设计","lang":"zh-CN","frontmatter":{"description":"kafka架构设计 持久化设计 kafka深度依赖文件系统来存储或者缓存message。磁盘的快慢取决于使用的方式， 在某些情况下，顺序磁盘访问可能比随机内存访问更快。 现代操作系统会尽可能地将所有空闲内存用于磁盘缓存，当内存需要被回收时，性能损耗也非常小。 所有的磁盘读写操作都会用到这个缓存，因此，对于用户进程中的内存数据，如果涉及到写磁盘， 那么该...","head":[["meta",{"property":"og:url","content":"https://njustlcx.github.io/veins/veins/backend/message/kafka%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Veins"}],["meta",{"property":"og:title","content":"kafka架构设计"}],["meta",{"property":"og:description","content":"kafka架构设计 持久化设计 kafka深度依赖文件系统来存储或者缓存message。磁盘的快慢取决于使用的方式， 在某些情况下，顺序磁盘访问可能比随机内存访问更快。 现代操作系统会尽可能地将所有空闲内存用于磁盘缓存，当内存需要被回收时，性能损耗也非常小。 所有的磁盘读写操作都会用到这个缓存，因此，对于用户进程中的内存数据，如果涉及到写磁盘， 那么该..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-05T13:35:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-05T13:35:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"kafka架构设计\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-05T13:35:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小驴哥\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"git":{"createdTime":1748181397000,"updatedTime":1749130542000,"contributors":[{"name":"lvchaoxian","username":"lvchaoxian","email":"lvchaoxian@meituan.com","commits":3,"url":"https://github.com/lvchaoxian"},{"name":"lvchaoxian","username":"lvchaoxian","email":"njustlcx@gmail.com","commits":1,"url":"https://github.com/lvchaoxian"}]},"readingTime":{"minutes":1.63,"words":488},"filePathRelative":"backend/message/kafka技术原理.md","localizedDate":"2025年5月25日","excerpt":"\\n<h2>持久化设计</h2>\\n<p>kafka深度依赖文件系统来存储或者缓存message。磁盘的快慢取决于使用的方式，<br>\\n在某些情况下，顺序磁盘访问可能比随机内存访问更快。<br>\\n现代操作系统会尽可能地将所有空闲内存用于磁盘缓存，当内存需要被回收时，性能损耗也非常小。<br>\\n所有的磁盘读写操作都会用到这个缓存，因此，对于用户进程中的内存数据，如果涉及到写磁盘，<br>\\n那么该数据可能会同时存放了两份。<br>\\n对于内存中的数据，相当于缓存可以扩大一倍，在JVM环境下甚至扩大更多。<br>\\n</p>\\n<h3>读写常数时间复杂度</h3>\\n<p>持久化队列，读写互相不阻塞</p>\\n<h2>kafka如何保证高性能</h2>","autoDesc":true}');export{m as comp,l as data};
